local {
  def suf{T} = {
    if (isfloat{T}) (if (width{T}==32) 'ps' else 'pd')
    else merge{'epi', fmtnat{width{T}}}
  }
  def suf{[_]T} = suf{T}
  def pref{w} = merge{'_mm', if (w==128) '' else fmtnat{w}, '_'}
  def pref{V=[_]_} = pref{width{V}}
}

local def re_mask{[l]_, sub} = {
  def w = max{32,l}
  sub{fmtnat{l}, fmtnat{w}, ty_u{w}}
}
def reinterpret{M=[l==width{T}](u1), a:T} = {
  re_mask{M, {l,w,W} => emit{M, merge{'_cvtu',w,'_mask',l}, promote{W, a}}}
}
def reinterpret{T, a:M=[l==width{T}](u1)} = {
  re_mask{M, {l,w,W} => cast_i{T, emit{W, merge{'_cvtmask',l,'_u',w}, a}}}
}

def maskStore{p:*V, m:[l](u1), v:V=[l]_} = {
  emit{void, merge{pref{V}, 'mask_storeu_', suf{V}}, p, m, v}
}

def topMaskReg{x:V=[k]_} = emit{[k]u1, merge{pref{V},'mov',suf{V},'_mask'}, x}
def topMask{x:V=[k]_ if 512==width{V}} = ty_u{k}~~topMaskReg{x}
def homMask{x:V=[_]_ if 512==width{V}} = topMask{x}

def maskToHom{V=[l]_, x:[l](u1)} = emit{V, merge{pref{V},'movm_',suf{V}}, x}
