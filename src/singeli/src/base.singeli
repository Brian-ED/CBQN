include 'skin/c'
include 'arch/c'
def Size = u64
oper infix right ~~ reinterpret 55

def load{x} = *x
# TODO move these to a more base file
def knum{x} = match{'number',kind{x}}
def trunc{T, x:U & isint{T} & isint{U} & T<=U} = emit{T, '', x}
def ext  {T, x:U & isint{T} & isint{U} & T>=U} = emit{T, '', x}
def trunc{T, x & knum{x}} = cast{T, x}
def ext  {T, x & knum{x}} = cast{T, x}

# basic ceiling divide
def cdiv{a,b} = (a+b-1)/b

# base-2 log of a constant power of two
def lb{n & knum{n} & (n>>1<<1) == n & n>0} = lb{n>>1}+1
def lb{n==1} = 0

def tail{n,x} = x - (x>>n << n) # get the n least significant bits
def bit {k,x} = tail{1,x>>k} << k # get the k-th bit

def rare{x:u1} = emit{u1, '__builtin_expect', x, 0}
def isunsigned{T} = isint{T} & ~issigned{T}
def assert{x:u1} = emit{void, 'si_assert', x}

def cast_p{T, x} = emit{*T, '(void*)', x}

def anyNum{x} = knum{x}
def anyNum{x & match{'constant',kind{x}}} = 1
def anyNum{x:T} = match{'primitive',typekind{T}}

def anyInt{x} = knum{x}
def anyInt{x & match{'register',kind{x}} | match{'constant',kind{x}}} = isint{x}


def __add{a:T,b & match{'pointer',typekind{T}} & anyInt{b}} = emit{T, 'op +', a, b}
def __sub{a:T,b & match{'pointer',typekind{T}} & anyInt{b}} = emit{T, 'op +', a, b}

def tern{c, T, F & anyInt{c}} = {
  if(c) T
  else F
}


def ty_u{T==i8 } = u8;  def ty_u{w== 8} = u8
def ty_u{T==i16} = u16; def ty_u{w==16} = u16
def ty_u{T==i32} = u32; def ty_u{w==32} = u32
def ty_u{T==i64} = u64; def ty_u{w==64} = u64
def ty_s{T==u8 } = i8;  def ty_s{w== 8} = i8
def ty_s{T==u16} = i16; def ty_s{w==16} = i16
def ty_s{T==u32} = i32; def ty_s{w==32} = i32
def ty_s{T==u64} = i64; def ty_s{w==64} = i64

def ty_u{T==f64} = u64; def ty_u{T==f32} = u32;
def ty_s{T==f64} = i64; def ty_s{T==f32} = i32;

def ty_vu{T & isvec{T}} = [vcount{T}](ty_u{eltype{T}})
def ty_vs{T & isvec{T}} = [vcount{T}](ty_s{eltype{T}})
def ty_vs{x:T} = ty_vs{T}~~x
def ty_vu{x:T} = ty_vu{T}~~x

def unroll{vars,begin,end,block & knum{begin} & knum{end}} = {
  def f{i,l & i==l} = 0
  def f{i,l & i!=l} = {
    exec{i, vars, block}
    f{i+1, l}
  }
  f{begin,end}
}
def collect{vars,begin,end,block & knum{begin} & knum{end}} = {
  def f{i,l & i==l} = tup{}
  def f{i,l & i!=l} = {
    def r = exec{i, vars, block}
    merge{tup{r}, f{i+1, l}}
  }
  f{begin,end}
}
def for{vars,begin,end,block} = {
  i:u64 = begin
  while (i < end) {
    exec{i, vars, block}
    i = i+1
  }
}
def forc{F} {vars,begin,end,block} = {
  i:u64 = begin
  while (i < end) {
    exec{i, each{F, vars}, block}
    i = i+1
  }
}

def maxvalue{T & T==u8 } = 0xff
def maxvalue{T & T==u16} = 0xffff
def maxvalue{T & T==u32} = 0xffffffff

# various utilities
def      isintv{T} =      isint{eltype{T}}
def    isfloatv{T} =    isfloat{eltype{T}}
def   issignedv{T} =   issigned{eltype{T}}
def isunsignedv{T} = isunsigned{eltype{T}}
def istype{T} = match{kind{T},'type'}
def istup{T} = match{kind{T},'tuple'}
def isvec{T} = 0
def isvec{T & istype{T}} = match{typekind{T},'vector'}


# non-vector variants of vector defs
def broadcast{T, v & match{typekind{T},'primitive'}} = v
def any{v:T & match{typekind{T},'primitive'}} = v
def anyneg{v:T & match{typekind{T},'primitive'}} = v<0
def iota{n & knum{n}} = @collect(i to n) i
def broadcast{n, v & knum{n}} = @collect(n) v


# debug stuff
def print{x & match{kind{x},'symbol'}} = { emit{void, 'printf', '"%s"', merge{'"', x, '"'}}; x }
def print{x & anyNum{x}} = { emit{void, 'printf', tern{issigned{x}, '"%d"', '"%u"'}, x}; x }
def print{x:T & anyNum{x} & width{T}==64} = { emit{void, 'printf', tern{issigned{x}, '"%ld"', '"%lu"'}, x}; x }
def println{x} = { print{x}; print{'\n'}; x }