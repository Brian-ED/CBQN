include './base'
if (hasarch{'AVX2'}) {
  include './sse'
  include './avx'
  include './avx2'
}
include './mask'
include 'util/tup'

def for_backwards{vars,begin,end,iter} = {
  i:u64 = end
  while (i > begin) {
    --i
    iter{i, vars}
  }
}
def for_vec_overlap{vl}{vars,begin==0,n,iter} = {
  assert{n >= vl}
  def end = makelabel{}
  j:u64 = 0
  while (1) {
    iter{j, vars}
    j += vl
    if (j > n-vl) { if (j == n) goto{end}; j = n-vl }
  }
  setlabel{end}
}

def ceil_log2{n:u64} = 64 - clz{n-1}

# Shift as u16, since x86 is missing 8-bit shifts
def shr16{v, n} = type{v}~~(([width{type{v}}/16]u16~~v) >> n)

def rtypes = tup{i8, i16, i32, f64}
# Return index of smallest possible result type given max result value
def get_rtype{len} = {
  t:u8 = 0
  def c{T, ...ts} = if (len>maxvalue{T}) { ++t; c{...ts} }
  def c{T==f64} = {}
  c{...rtypes}
  t
}
def rtype_arr{gen} = {
  def t = each{gen, rtypes}
  a:*(type{tupsel{0,t}}) = t
}

# Write the last index of v at t+v, for each unique v in w
fn write_indices{I,T}(t:*I, w:*T, n:u64) : void = {
  def break = makelabel{}
  i:u64 = 0; while (1) {
    d:u64 = 16
    id := i+d
    wi := undefined{T}
    if (id >= n) {
      @for (w over j from i to n) store{t, w, j+1}
      goto{break}
    } else if ((wi = load{w, i}) == load{w, id}) {
      md := n - i
      d2 := undefined{u64}
      while ((d2=d+d) < md and wi == load{w, i + d2}) d = d2
      i += d
      l := n - i; if (l > d) l = d
      # Last instance of wi in [i,i+l); shrink l
      while (l > 8) {
        h := l/2
        m := i + h
        if (wi == load{w, m}) i = m
        l -= h
      }
    } else {
      @unroll (j to 8) store{t, load{w, i+j}, i+j+1}
      i += 8
    }
  }
  setlabel{break}
}
fn lookup_indices{I,T,R}(tab:*I, x:*T, rp:*void, xn:u64) : void = {
  def m = 1<<width{T}
  t := *R~~tab; ts := t+m/2
  @for (tab, t over m) t = cast_i{R, tab}
  @for (r in *R~~rp, x in *T~~x over xn) r = load{ts, x}
}
def lookup_i8_arr = rtype_arr{bind{lookup_indices,u64,i8}}

def bin_search_vec{up, w:*i8, wn, x:*i8, n, res:*i8} = {
  assert{wn > 0}
  def T = i8; def I = u8
  def lt = if (up) <; else >
  def pre = (if (up) minvalue else maxvalue){T}
  def vl = 32
  def V = [vl]T; def H = [vl/2]T
  def U = [vl]I
  def getsel{h:(H)} = {
    v := pair{h,h}
    {i} => sel{H, v, i}
  }
  if (hasarch{'AVX2'} and wn < 16) {
    log := ceil_log2{wn+1}
    l := 1<<log
    gap := l - cast_i{u8, wn}
    off := U**(gap - 1)
    wv := homBlend{load{*H~~(w-gap), 0}, H**pre, maskOf{H,gap}}
    def selw = getsel{wv}
    h0 := U**(l/2)
    @unroll (klog from 2 to 5) {
      if (log==klog) @for_vec_overlap{vl} (j to n) {
        xv:= load{*V~~(x+j), 0}
        s := U**0
        h := h0
        @unroll (klog) {
          s |= h &~ lt{xv, selw{s | h}}
          h = shr16{h, 1}
        }
        store{*U~~(res+j), 0, s - off}
      }
    }
  } else {
    assert{wn < 128} # Total must fit in i8
    t0:*i8 = copy{256,0}
    t:*i8 = t0 + 128
    @for (w over wn) store{t, w, 1+load{t, w}}
    def plus_scan{tab, len} = {
      def for_dir = if (up) for else for_backwards
      s:i8=0; @for_dir (tab over len) { s += tab; tab = s }
    }
    def getm{} = { m:=V**0; @unroll (v in *V~~t0 over 256/vl) m = max{m,v}; m }
    if (hasarch{'AVX2'} and homAll{getm{} <= V**1}) {
      # Convert to bit table
      def nb = 256/vl
      vb := U~~make{[nb](ty_u{vl}),
        @collect (t in *V~~t0 over nb) homMask{t > V**0}
      }
      # Popcount on 8-bit values
      def sums{n} = if (n==1) tup{0} else { def s=sums{n/2}; merge{s,s+1} }
      def sum4 = getsel{make{H, sums{vl/2}}}
      bot4 := U**0x0f
      def vpopc{v} = {
        def s{b} = sum4{b&bot4}
        s{shr16{v,4}} + s{v}
      }
      # 32-byte select
      vtop := U**(vl/2)
      def getsel{v & width{type{v}}==256} = {
        hs := each{bind{shuf, [4]u64, v}, tup{4b3232, 4b1010}}
        {i} => homBlend{...each{{h}=>sel{H,h,i}, hs}, i<vtop}
      }
      def swap{v} = shuf{[4]u64, v, 4b1032} # For signedness
      # Bit table
      def sel_b = getsel{swap{vb}}
      # Masks for filtering bit table
      def ms = if (up) 256-(1<<(1+iota{8})) else (1<<iota{8})-1
      def sel_m = getsel{make{H, merge{ms - 256*(ms>127), 8**0}}}
      # Exact values for multiples of 8
      store{*U~~t0, 0, vpopc{vb}}
      plus_scan{t0, 256/8}
      def sel_c = getsel{swap{load{*V~~t0, 0}}}
      # Top 5 bits select bytes from tables; bottom 3 select from mask
      bot3 := U**0x07
      @for_vec_overlap{vl} (j to n) {
        xv := load{*U~~(x+j), 0}
        xb := xv & bot3
        xt := shr16{xv &~ bot3, 3}
        ind := sel_c{xt} - vpopc{sel_b{xt} & U~~sel_m{xb}}
        store{*U~~(res+j), 0, ind}
      }
    } else {
      plus_scan{t0, 256}
      @for (res, x over n) res = load{t, x}
    }
  }
}

def unroll_sizes = tup{4,1}
fn write{T,k}(r:*void, i:u64, ...vs:k**u64) : void = {
  each{{j,v} => store{*T~~r, i+j, cast_i{T,v}}, iota{k}, vs}
}
def wr_arrs = each{{k} => rtype_arr{{T} => write{T,k}}, unroll_sizes}

def bin_search_branchless{up, w, wn, x, n, res, rtype} = {
  def lt = if (up) <; else >
  ws := w - 1
  l0 := wn + 1
  # Take a list of indices in x/res to allow unrolling
  def search{inds} = {
    xs:= each{bind{load,x}, inds} # Values
    ss:= each{{_}=>ws, inds}      # Initial lower bound
    l := l0; h := undefined{u64}  # Interval size l, same for all values
    while ((h=l/2) > 0) {
      # Branchless update
      def bin1{s, x, m} = { if (not lt{x, load{m}}) s = m }
      each{bin1, ss, xs, each{bind{+,h}, ss}}
      l -= h
    }
    each{{s} => u64~~(s - ws), ss}
  }
  # Unroll by 4 then 1
  def search{i, k} = search{each{bind{+,i}, iota{k}}}
  j:u64 = 0
  def searches{k, wr_arr} = {
    wr := load{wr_arr, rtype}
    while (j+k <= n) { wr(res, j, ...search{j, k}); j+=k }
  }
  each{searches, unroll_sizes, wr_arrs}
}

fn bins{T, up}(w:*void, wn:u64, x:*void, xn:u64, rp:*void, rty:u8) : void = {
  if (T==i8 and wn<128 and xn>=32) {
    bin_search_vec{up, *T~~w, wn, *T~~x, xn, *i8~~rp}
  } else if (T==i8 and xn>=64 and (xn>=1024 or (xn-32) >= cast_i{u64,1}<<(ceil_log2{wn}/2+1))) {
    def T = i8; def I = u64
    t0:*I = copy{256,0}
    t:*I = t0 + 128
    write_indices{I,T}(t, *T~~w, wn)
    def for_dir = if (up) for else for_backwards
    s:I=0; @for_dir (t0 over 256) { if (t0 > s) s = t0; t0 = s }
    load{lookup_i8_arr,rty}(t0, *T~~x, rp, xn)
  } else {
    bin_search_branchless{up, *T~~w, wn, *T~~x, xn, rp, rty}
  }
}

exportT{
  'si_bins',
  join{table{bins, tup{i8,i16,i32,f64}, tup{1,0}}}
}
