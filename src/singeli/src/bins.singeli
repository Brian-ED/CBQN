include './base'
if (hasarch{'AVX2'}) {
  include './sse'
  include './avx'
  include './avx2'
}
include './mask'
include 'util/tup'

def for_backwards{vars,begin,end,iter} = {
  i:u64 = end
  while (i > begin) {
    --i
    iter{i, vars}
  }
}
def for_dir{up} = if (up) for else for_backwards
def for_vec_overlap{vl}{vars,begin==0,n,iter} = {
  assert{n >= vl}
  def end = makelabel{}
  j:u64 = 0
  while (1) {
    iter{j, vars}
    j += vl
    if (j > n-vl) { if (j == n) goto{end}; j = n-vl }
  }
  setlabel{end}
}

def ceil_log2{n:u64} = 64 - clz{n-1}

# Shift as u16, since x86 is missing 8-bit shifts
def shr16{v, n} = type{v}~~(([width{type{v}}/16]u16~~v) >> n)

# Forward or backwards in-place max-scan
# Assumes a whole number of vectors and minimum 0
fn max_scan{T, up}(x:*T, len:u64) : void = {
  def w = width{T}
  if (hasarch{'AVX2'} and T!=u64) {
    def op = max
    # TODO unify with scan.singeli avx2_scan_idem
    def rev{a} = if (up) a else (tuplen{a}-1)-reverse{a}
    def maker{T, l} = make{T, rev{l}}
    def sel8{v, t} = sel{[16]u8, v, maker{[32]i8, t}}
    def sel8{v, t & istup{t} & tuplen{t}==16} = sel8{v, merge{t,t}}
    def shuf{T, v, n & istup{n}} = shuf{T, v, base{4,rev{n}}}
    def spread{a:VT} = {
      def w = elwidth{VT}
      def b = w/8
      if (w<=16) sel8{a,merge{iota{12},(16-b)+iota{4}%b}}; else a
    }
    def shift{k,l} = merge{iota{k},iota{l-k}}
    def c8 {k, a} = op{a, shuf{[4]u32, a, shift{k,4}}}
    def c32{k, a} = (if (w<=8*k) op{a, sel8{a, shift{k,16}}}; else a)
    def pre{a} = {
      b:= c8{2, c8{1, c32{2, c32{1, a}}}}
      op{b, sel{[8]i32, spread{b}, maker{[8]i32, 3*(3<iota{8})}}}
    }
    def toLast{n:VT} = {
      if (elwidth{VT}<=32) sel{[8]i32, spread{n}, [8]i32**(up*7)}
      else shuf{[4]u64, n, up*4b3333}
    }
    def vl = 256/w
    def V = [vl]T
    p := V**0
    @for_dir{up} (v in *V~~x over len/vl) { v = op{pre{v}, p}; p = toLast{v} }
  } else {
    m:T=0; @for_dir{up} (x over len) { if (x > m) m = x; x = m }
  }
}

def fmt_type{T} = {
  def w = width{T}
  merge{quality{T}, if (w==8) '8' else if (w==16) '16' else if (w==32) '32' else '64'}
}
def talloc{T, len} = emit{*T, 'TALLOCP', fmt_type{T}, len}
def tfree{ptr} = emit{void, 'TFREE', ptr}

def getsel{...x} = assert{'shuffling not supported', show{...x}}
if (hasarch{'AVX2'}) {
  def getsel{h:H & lvec{H, 16, 8}} = {
    v := pair{h,h}
    {i} => sel{H, v, i}
  }
  def getsel{v:V & lvec{V, 32, 8}} = {
    def H = v_half{V}
    vtop := V**(vcount{V}/2)
    hs := each{bind{shuf, [4]u64, v}, tup{4b3232, 4b1010}}
    {i} => homBlend{...each{{h}=>sel{H,h,i}, hs}, V~~i<vtop}
  }
}

def rtypes = tup{i8, i16, i32, f64}
# Return index of smallest possible result type given max result value
def get_rtype{len} = {
  t:u8 = 0
  def c{T, ...ts} = if (len>maxvalue{T}) { ++t; c{...ts} }
  def c{T==f64} = {}
  c{...rtypes}
  t
}
def rtype_arr{gen} = {
  def t = each{gen, rtypes}
  a:*(type{tupsel{0,t}}) = t
}

# Write the last index of v at t+v, for each unique v in w
fn write_indices{I,T}(t:*I, w:*T, n:u64) : void = {
  def break = makelabel{}
  i:u64 = 0; while (1) {
    d:u64 = 16
    id := i+d
    wi := undefined{T}
    if (id >= n) {
      @for (w over j from i to n) store{t, w, j+1}
      goto{break}
    } else if ((wi = load{w, i}) == load{w, id}) {
      md := n - i
      d2 := undefined{u64}
      while ((d2=d+d) < md and wi == load{w, i + d2}) d = d2
      i += d
      l := n - i; if (l > d) l = d
      # Last instance of wi in [i,i+l); shrink l
      while (l > 8) {
        h := l/2
        m := i + h
        if (wi == load{w, m}) i = m
        l -= h
      }
    } else {
      @unroll (j to 8) store{t, load{w, i+j}, i+j+1}
      i += 8
    }
  }
  setlabel{break}
}
def bins_lookup{I, T, up, w:*T, wn:u64, x:*T, xn:u64, rp:*void} = {
  def tc = 1<<width{T}
  t0:*I = talloc{I, tc}
  @for (t0 over tc) t0 = 0
  t:*I = t0 + tc/2
  write_indices{I,T}(t, *T~~w, wn)
  max_scan{I, up}(t0, tc)
  @for (r in *I~~rp, x over xn) r = load{t, x}
  tfree{t0}
}

def bins_lookup{I==i8, T==i8, up, w:*T, wn:u64, x:*T, xn:u64, rp:*void & hasarch{'AVX2'}} = {
  assert{wn < 128} # Total must fit in i8
  def T = i8
  def vl = 32
  def V = [vl]T; def H = v_half{V}
  def U = [vl]u8
  def res = *T~~rp

  t0:*i8 = copy{256,0}
  t:*i8 = t0 + 128
  @for (w over wn) store{t, w, 1+load{t, w}}
  def plus_scan{tab, len} = {
    s:i8=0; @for_dir{up} (tab over len) { s += tab; tab = s }
  }

  # Convert to bit table
  def no_bittab = makelabel{}; def done = makelabel{}
  def nb = 256/vl
  nu:u8 = 0; def addu{b} = { nu+=popc{b}; b } # Number of uniques
  vb := U~~make{[nb](ty_u{vl}),
    @collect (t in *V~~t0 over nb) addu{homMask{t > V**0}}
  }
  dup := promote{u64,nu} < wn
  # Unique index to w index conversion
  ui := undefined{V}; ui1 := undefined{V}
  if (dup) {
    if (nu > vl) goto{no_bittab}
    # We'll subtract 1 when indexing so the initial 0 isn't needed
    tui:*i8 = copy{vl, 0}; i:T = 0
    @for (tui over promote{u64,nu}) { i += load{t, load{w, i}}; tui = i }
    ui = load{*V~~tui, 0}
    if (nu > 16) ui1 = shuf{[4]u64, ui, 4b3232}
    ui = shuf{[4]u64, ui, 4b1010}
  }
  # Popcount on 8-bit values
  def sums{n} = if (n==1) tup{0} else { def s=sums{n/2}; merge{s,s+1} }
  def sum4 = getsel{make{H, sums{vl/2}}}
  bot4 := U**0x0f
  def vpopc{v} = {
    def s{b} = sum4{b&bot4}
    s{shr16{v,4}} + s{v}
  }
  # Bit table
  def swap{v} = shuf{[4]u64, v, 4b1032} # For signedness
  def sel_b = getsel{swap{vb}}
  # Masks for filtering bit table
  def ms = if (up) 256-(1<<(1+iota{8})) else (1<<iota{8})-1
  def sel_m = getsel{make{H, merge{ms - 256*(ms>127), 8**0}}}
  # Exact values for multiples of 8
  store{*U~~t0, 0, vpopc{vb}}
  plus_scan{t0, 256/8}
  def sel_c = getsel{swap{load{*V~~t0, 0} - V**dup}}
  # Top 5 bits select bytes from tables; bottom 3 select from mask
  bot3 := U**0x07
  @for_vec_overlap{vl} (j to xn) {
    xv := load{*U~~(x+j), 0}
    xb := xv & bot3
    xt := shr16{xv &~ bot3, 3}
    ind := sel_c{xt} - vpopc{sel_b{xt} & U~~sel_m{xb}}
    if (dup) {
      i0 := V~~ind # Can contain -1
      ind = sel{H, ui, i0}
      if (nu > 16) ind = homBlend{sel{H,ui1,i0}, ind, i0<V**(vl/2)}
    }
    store{*U~~(res+j), 0, ind}
  }
  goto{done}
  setlabel{no_bittab}

  plus_scan{t0, 256}
  @for (res, x over xn) res = load{t, x}
  setlabel{done}
}

def bin_search_vec{T, up, w:*T, wn, x:*T, xn, rp, maxwn & hasarch{'AVX2'}} = {
  assert{wn > 1}
  def wd = width{T}
  def bytes = wd/8; def bb = bind{base,256}
  def vl = 256/wd
  def V = [vl]T; def H = v_half{V}
  def U = [vl](ty_u{T})
  def lt = if (up) <; else >
  # Number of steps
  log := ceil_log2{wn+1}
  l := 1<<log
  gap := l - cast_i{u8, wn}
  off := [vl]u8**(gap - 1)
  # Fill with minimum value at the beginning
  def pre = (if (up) minvalue else maxvalue){T}
  wv := homBlend{load{*H~~(w-gap), 0}, H**pre, maskOf{H,gap}}
  def selw = getsel{[16]u8~~wv}
  # A bit in every byte
  h0 := U**(bb{copy{bytes,bytes}} * (cast_i{ty_u{T},l}/2))
  @unroll (klog from 2 to lb{maxwn}+1) {
    if (log==klog) @for_vec_overlap{vl} (j to xn) {
      xv:= load{*V~~(x+j), 0}
      s := U**bb{iota{bytes}}  # Select sequential bytes within each U
      h := h0
      @unroll (klog) {
        m := s | h
        s = homBlend{m, s, lt{xv, V~~selw{to_el{u8,m}}}}
        h = shr16{h, 1}
      }
      r := if (T==i8) s
           else half{narrow{u8, s>>(lb{bytes}+wd-8)}, 0}
      store{*[vl]i8~~(*i8~~rp+j), 0, r - off}
    }
  }
}

def unroll_sizes = tup{4,1}
fn write{T,k}(r:*void, i:u64, ...vs:k**u64) : void = {
  each{{j,v} => store{*T~~r, i+j, cast_i{T,v}}, iota{k}, vs}
}
def wr_arrs = each{{k} => rtype_arr{{T} => write{T,k}}, unroll_sizes}

def bin_search_branchless{up, w, wn, x, n, res, rtype} = {
  def lt = if (up) <; else >
  ws := w - 1
  l0 := wn + 1
  # Take a list of indices in x/res to allow unrolling
  def search{inds} = {
    xs:= each{bind{load,x}, inds} # Values
    ss:= each{{_}=>ws, inds}      # Initial lower bound
    l := l0; h := undefined{u64}  # Interval size l, same for all values
    while ((h=l/2) > 0) {
      # Branchless update
      def bin1{s, x, m} = { if (not lt{x, load{m}}) s = m }
      each{bin1, ss, xs, each{bind{+,h}, ss}}
      l -= h
    }
    each{{s} => u64~~(s - ws), ss}
  }
  # Unroll by 4 then 1
  def search{i, k} = search{each{bind{+,i}, iota{k}}}
  j:u64 = 0
  def searches{k, wr_arr} = {
    wr := load{wr_arr, rtype}
    while (j+k <= n) { wr(res, j, ...search{j, k}); j+=k }
  }
  each{searches, unroll_sizes, wr_arrs}
}

fn bins{T, up}(w:*void, wn:u64, x:*void, xn:u64, rp:*void, rty:u8) : void = {
  def param = tup{up, *T~~w, wn, *T~~x, xn, rp}
  def lookup{k} = {
    if (rty == k) bins_lookup{tupsel{k,rtypes}, T, ...param}
    else if (k+1 < tuplen{rtypes}) lookup{k+1}
  }
  if (hasarch{'AVX2'} and T<=i16 and wn < 8 and xn >= 256/width{T}) {
    bin_search_vec{T, ...param, 8}
  # Lookup table threshold has to account for cost of
  # populating the table (proportional to wn until it's large), and
  # initializing the table (constant, much higher for i16)
  } else if (T==i8 and xn>=32 and (xn>=512 or xn >= wn>>6 + 32)) {
    lookup{0}
  } else if (T==i16 and xn>=512 and (xn>=1<<14 or xn >= wn>>6 + (u64~~3<<(12+rty))/promote{u64,ceil_log2{wn}+2})) {
    lookup{0}
  } else {
    bin_search_branchless{...param, rty}
  }
}

exportT{
  'si_bins',
  join{table{bins, tup{i8,i16,i32,f64}, tup{1,0}}}
}
