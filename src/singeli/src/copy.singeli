include './base'
include './debug'
if (hasarch{'X86_64'}) {
  include './sse3'
  include './avx'
  include './avx2'
} else if (hasarch{'AARCH64'}) {
  include './neon'
}
include './mask'
include './cbqnDefs'
include './bitops'

def copyFromBits{T, loadFn, rp, l:u64} = {
  def bulk = vcount{T}
  def TU = ty_u{T}
  
  maskedLoop{bulk, l, {i, M} => {
    x:= loadFn{TU, i}
    r:= x & TU ~~ T**1
    storeBatch{*eltype{T}~~rp, i, T~~r, M}
  }}
}


copy{X, R}(x: *void, r: *void, l:u64, xRaw: *void) : void = {
  def vw = arch_defvw
  assert{l!=0}
  
  def bulk = vw/max{width{X}, width{R}}
  xp:= *tern{X==u1, u64, X} ~~ x
  rp:= *tern{R==u1, u64, R} ~~ r
  def XV = [bulk]X
  def RV = [bulk]R
  def ur = tern{hasarch{'AARCH64'}, 4, 1}
  
  if (R==u64) {
    # show{'R==u64', X, R}
    assert{((X==u8) | (X==u16)) | (X==u32)}
    maskedLoop{bulk, l, {i, M} => { # TODO could maybe read 256 bits and use unpack to write >256
      v:= loadBatch{xp, i, RV}
      v|= RV ** (cbqn_c32Tag{} << 48)
      storeBatch{rp, i, v, M}
    }}
  } else if (X==u1 and R==u1) {
    # show{'u1u1', X, R}
    def V64 = [vw/64]u64
    maskedLoop{vcount{V64}, cdiv{l, 64}, {i, M} => {
      v:= loadBatch{xp, i, V64}
      storeBatch{rp, i, v, M}
    }}
  } else if (X==u1) {
    # show{'X==u1', X, R}
    copyFromBits{[bulk]R, {T, i} => loadBatchBit{T, xp, i}, r, l}
  } else if (R==u1) {
    # show{'R==u1', X, R}
    def XU = ty_u{XV}
    @forNZ (i to cdiv{l,vcount{XV}}) {
      v:= loadBatch{xp, i, XV}
      r:= homMask{(XU~~v) == XU~~XV**1}
      b_setBatch{vcount{XV}, rp, i, r} # TODO something more special for f64
    }
  } else if (width{X}<=width{R}) {
    # show{'w{X}<=w{R}', X, R}
    muLoop{bulk, ur, l, {is, M} => {
      def v = loadBatch{xp, is, RV}
      storeBatch{rp, is, v, M}
    }}
  } else {
    # show{'w{X}>w{R}', X, R}
    muLoop{bulk, ur, l, {is, M} => {
      def v = loadBatch{xp, is, XV}
      storeBatch{rp, is, v, M}
    }}
  }
}

copy_ubit{R}(x: *void, r: *void, l:u64, xRaw: *void) : void = {
  assert{l!=0}
  x0:= (*u8~~xRaw) + cbqn_tyArrOffset{}
  xs:= u64~~((*u8~~x) - x0)
  # if ((xs&7)==0) {
  #   copy{u1, R}(*void~~(x0 + (xs>>3)), r, l, xRaw)
  # } else {
  def vw = arch_defvw
  def bulk = vw/width{R}
  def RV = [bulk]R
  rp:= *R~~r
  
  copyFromBits{RV, {T, i} => spreadBits{T, loaduBitTrunc{*u64~~x0, xs+i*vcount{T}, vcount{T}}}, r, l}
  # }
}

# simd_copy_src_dst
# x→int & equal-width copies
'simd_copy_1_1'     = copy{u1,  u1}
'simd_copy_1_i8'    = copy{u1,  i8}
'simd_copy_1_i16'   = copy{u1,  i16}
'simd_copy_1_i32'   = copy{u1,  i32}

'simd_copy_i8_1'    = copy{i8,  u1}
'simd_copy_i8_i8', 'simd_copy_c8_c8' = copy{i8,  i8}
'simd_copy_i8_i16'  = copy{i8,  i16}
'simd_copy_i8_i32'  = copy{i8,  i32}

'simd_copy_i16_1'   = copy{i16, u1}
'simd_copy_i16_i8'  = copy{i16, i8}
'simd_copy_i16_i16', 'simd_copy_c16_c16' = copy{i16, i16}
'simd_copy_i16_i32' = copy{i16, i32}

'simd_copy_i32_1'   = copy{i32, u1}
'simd_copy_i32_i8'  = copy{i32, i8}
'simd_copy_i32_i16' = copy{i32, i16}
'simd_copy_i32_i32', 'simd_copy_c32_c32'= copy{i32, i32}

'simd_copy_f64_1'   = copy{f64, u1}
'simd_copy_f64_i8'  = copy{f64, i8}
'simd_copy_f64_i16' = copy{f64, i16}
'simd_copy_f64_i32' = copy{f64, i32}

# x→f64, x→B (no simd_copy_B_B because that may possibly need refcounting)
'simd_copy_1_f64',   'simd_copy_1_B'   = copy{u1,  f64}
'simd_copy_i8_f64',  'simd_copy_i8_B'  = copy{i8,  f64}
'simd_copy_i16_f64', 'simd_copy_i16_B' = copy{i16, f64}
'simd_copy_i32_f64', 'simd_copy_i32_B' = copy{i32, f64}
'simd_copy_f64_f64', 'simd_copy_f64_B' = copy{f64, f64}

# chr→x
'simd_copy_c8_c16'  = copy{u8, u16}
'simd_copy_c8_c32'  = copy{u8, u32}
'simd_copy_c8_B'    = copy{u8, u64}

'simd_copy_c16_c8'  = copy{u16, u8}
'simd_copy_c16_c32' = copy{u16, u32}
'simd_copy_c16_B'   = copy{u16, u64}

'simd_copy_c32_c8'  = copy{u32, u8}
'simd_copy_c32_c16' = copy{u32, u16}
'simd_copy_c32_B'   = copy{u32, u64}

# B→chr
'simd_copy_B_c8'  = copy{u64, u8}
'simd_copy_B_c16' = copy{u64, u16}
'simd_copy_B_c32' = copy{u64, u32}

# unaligned bitarr widening
'simd_copy_1u_i8'    = copy_ubit{i8}
'simd_copy_1u_i16'   = copy_ubit{i16}
'simd_copy_1u_i32'   = copy_ubit{i32}
'simd_copy_1u_f64'   = copy_ubit{f64}