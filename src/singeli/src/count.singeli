include './base'
include './sse'
include './avx'
include './avx2'
include 'util/tup'
include './vecfold'

fn sum_vec{T==[32]i8}(v:T) = fold{+, [16]i16~~fold{+, unpackQ{v, T**0}}}
def minmax{c, a, b} = tern{c{cast_i{i8,a},cast_i{i8,b}}, a, b}
def min{a:i16, b:i16} = minmax{<, a, b}
def max{a:i16, b:i16} = minmax{>, a, b}

def inc{ptr, ind, v} = store{ptr, ind, v + load{ptr, ind}}
def inc{ptr, ind} = inc{ptr, ind, 1}

fn count{T}(tab:*usz, x:*ty_u{T}, n:u64) : u1 = {
  def vbits = 256
  def vec = vbits/width{T}
  def uT = ty_u{T}
  def V = [vec]T
  def block = (2048*8) / vbits  # Target vectors per block
  def b_max = block + block/4   # Last block max length
  assert{b_max < 1<<width{T}}   # Don't overflow count in vector section
  i:u64 = 0
  while (i < n) {
    # Number of elements to handle in this iteration
    r:u64 = n - i; if (r > vec*b_max) r = vec*block
    b := r / vec  # Vector case does b full vectors if it runs
    r0:u64 = 0    # Elements actually handled by vector case

    # Find range to check for suitability
    xv := *V~~x
    jv := load{xv}; mv := jv
    @for (xv over _ from 1 to b) { jv = min{jv, xv}; mv = max{mv, xv} }
    jt := fold{min, jv}
    mt := fold{max, mv} - jt # Counts needed (last one's implicit)
    if (jt < 0) return{1}    # Negative number found!

    if (mt <= 48) {
      r0 = b * vec
      j0 := promote{u64, uT~~jt} # Starting count
      m := promote{u64, uT~~mt}  # Number of iterations
      total := trunc{usz, r0}    # To compute last count
      def count_each{js, num} = {
        j := @collect (k to num) js+k
        c := copy{tuplen{j}, [vec]uT ** 0}
        e := each{{j}=>V**trunc{T, j}, j}
        @for (xv over b) each{{c,e} => c -= xv == e, c, e}
        def add_sum{c, j} = {
          s := promote{usz, sum_vec{V}(V~~c)}
          total -= s; inc{tab, j, s}
        }
        each{add_sum, c, j}
      }
      m4 := m / 4
      @for (j4 to m4) count_each{j0 + 4*j4, 4}
      @for (j from 4*m4 to m) count_each{j0 + j, 1}
      inc{tab, j0 + m, trunc{usz,total}}
    }

    # Scalar fallback and cleanup
    @for (x over _ from r0 to r) inc{tab, x}
    i += r
    x += r
  }
  0
}

export{'avx2_count_i8', count{i8}}
