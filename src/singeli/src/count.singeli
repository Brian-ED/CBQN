include './base'
include './sse'
include './avx'
include './avx2'
include 'util/tup'

# TODO merge with squeeze
def fold{F, x:T} = {
  show{'WARNING: using fallback fold'}
  def E = eltype{T}
  r:E = 0
  each{{i} => { r = F{r, extract{x, i}} }, iota{vcount{T}}}
  r
}
def fold{F, x:T & width{T}==128 & hasarch{'X86_64'}} = {
  c:= x
  def EW = elwidth{T}
  if (EW<=64) c = F{c, shuf{[4]u32, c, 4b1032}}
  if (EW<=32) c = F{c, shuf{[4]u32, c, 4b2301}}
  if (EW<=16) c = F{c, sel{[16]u8, c, make{[16]i8, iota{16}^2}}}
  if (EW<=8)  c = F{c, sel{[16]u8, c, make{[16]i8, iota{16}^1}}}
  extract{c, 0}
}
def fold{F, x:T & width{T}==256 & hasarch{'X86_64'}} = fold{F, F{half{x, 0}, half{x, 1}}}

fn sum_vec{T==[32]i8}(v:T) = fold{+, [16]i16~~fold{+, unpackQ{v, T**0}}}

def inc{ptr, ind, v} = store{ptr, ind, v + load{ptr, ind}}
def inc{ptr, ind} = inc{ptr, ind, 1}

fn count{T}(tab:*usz, x:*ty_u{T}, n:u64) : u1 = {
  def vbits = 256
  def vec = vbits/width{T}
  def uT = ty_u{T}
  def V = [vec]uT
  def iV = [vec]T
  def block = (2048*8) / vbits  # Target vectors per block
  assert{block < 1<<width{T}}   # Don't overflow count in vector section
  i:u64 = 0
  while (i < n) {
    r:u64 = n - i
    b := r / vec
    xv := *V~~x
    used_eq:u1 = 0
    if (r >= 128) {
      b = block; if (r < vec*b) b = r / vec
      jv := load{xv}; mv := jv
      @for (xv over _ from 1 to b) { jv = min{jv, xv}; mv = max{mv, xv} }
      mi := iV~~mv
      if (homAny{mi <  iV**0}) return{1}
      jt := fold{min, jv}
      if (homAll{mi <= iV**(48 + i8~~jt)}) {
        used_eq = 1
        r = b * vec
        j0 := promote{u64, jt}
        m := promote{u64, fold{max, mv}} - j0
        total := trunc{usz, b*vec}
        def count_each{js, num} = {
          j := (@collect (k to num) js+k)
          c := copy{tuplen{j}, V**0}
          e := each{{j}=>V**trunc{uT, j}, j}
          @for (xv over b) each{{c,e} => c -= xv == e, c, e}
          def add_sum{c, j} = {
            s := promote{usz, sum_vec{iV}(iV~~c)}
            total -= s; inc{tab, j, s}
          }
          each{add_sum, c, j}
        }
        m4 := m / 4
        @for (j4 to m4) count_each{j0 + 4*j4, 4}
        @for (j from 4*m4 to m) count_each{j0 + j, 1}
        inc{tab, j0 + m, trunc{usz,total}}
      }
    }
    if (not used_eq) @for (x over r) inc{tab, x}
    i += r
    x += r
  }
  0
}

export{'avx2_count_i8', count{i8}}
