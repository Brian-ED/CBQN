local include 'skin/cext'
local include './cbqnDefs'  # talloc/tfree

# Search primitives
# Function params are passed as names to keep generated code readable
def names = tup{'memberOf', 'count', 'indexOf'}
def prims = tup{'∊',        '⊒',     '⊐'      }
def map{{f,...fs}, {t,...ts}, v} = if (v==f) t else map{fs, ts, v}
def to_prim = map{names, prims, .}

# Defined in C
def memset{p:pT, v, l} = {
  emit{void, merge{'memset',fmtnat{elwidth{pT}}}, p, v, l}
}

# These hashes are stored in tables and must be invertible!
# Murmur3
def hash_val{x0:u32} = {
  x := x0
  x ^= x >> 16; x *= 0x85ebca6b
  x ^= x >> 13; x *= 0xc2b2ae35
  x ^= x >> 16; x
}
def hash_val{x0:u64} = {
  x := x0
  x ^= x >> 33; x *= 0xff51afd7ed558ccd
  x ^= x >> 33; x *= 0xc4ceb9fe1a85ec53
  x ^= x >> 33; x
}
# CRC32
def hash_val{x:u32 & hasarch{'SSE4.2'}} = {
  emit{u32, '_mm_crc32_u32', 0x973afb51, x}
}

# Allocate and initialize resizing hash table
# Initial size sz+ext and maximum size msz+ext
# One region for each type in Ts initialized with value from v0s
def hash_alloc{logsz, msz, ext, Ts, v0s} = {
  def ws = each{width,Ts}
  each{assert, slice{ws,0,-1} >= slice{ws,1}} # Doesn't do alignment
  # Variables updated on resize
  sz := usz~~1 << logsz
  sh := tupsel{0,ws} - logsz

  def add{}=0; def add{a,...r} = a+add{...r}
  halloc := talloc{u8, (msz+ext)*add{...ws/8}}
  szo := msz-sz  # Beginning of allocation to initial table
  sze := sz+ext  # Initial table to end of allocation
  def pe{{}} = halloc; def pl{{}} = tup{}
  def pe{{..._, p}} = p+sze  # Next unallocated space given pointers so far
  def pl{{...R, T}} = { def ps=pl{R}; tup{...ps, *T~~pe{ps}+szo} }
  ptrs := pl{Ts}
  each{memset{., ., sze}, ptrs, v0s}

  def hash_resize{cc, m} = {
    dif := sz*((1<<m)-1)
    sh -= m; sz <<= m
    j:usz = 0
    cc = 0
    each{{p,v} => { p -= dif; memset{p, v, dif} }, ptrs, v0s}
    def {hash, ...vals} = ptrs; def {h0, ...v0r} = v0s
    @for (j from dif to sz + ext) {
      h := hash->j
      if (h != h0) {
        hash <-{j} h0
        k0 := h>>sh; k := k0; while (hash->k!=h0) ++k
        cc += cast_i{usz, k-k0}
        hash <-{k} h
        each{{p,v0} => { v := p->j; p <-{j} v0; p <-{k} v }, vals, v0r}
      }
    }
  }

  tup{ptrs, sz, sh, hash_resize, {}=>tfree{halloc}}
}
