include './base'
if (hasarch{'AVX2'}) {
  include './sse'
  include './avx'
  include './avx2'
} else if (hasarch{'X86_64'}) {
  include './sse2'
} else if (hasarch{'AARCH64'}) {
  include './neon'
}
include './mask'

def ctzi{x} = promote{u64, ctz{x}}  # Count trailing zeros, as index

def findFirst{C, M, F, ...v1} = {
  def exit = makelabel{}
  def args = undef{M{...each{{c}=>tupsel{0,c}, v1}}}
  def am = tuplen{tupsel{0,v1}}
  each{{last, ...v2} => {
    if (last or C{...v2}) {
      each{=, args, M{...v2}}
      goto{exit}
    }
  }, iota{am} == am-1, ...v1}
  unreachable{}
  setlabel{exit}
  F{...args}
}

def search{E, x, n:u64, OP} = {
  def bulk = arch_defvw/width{E}
  def VT = [bulk]E
  def end = makeBranch{
    tup{u64, ty_u{VT}},
    {i,c} => return{i*bulk + ctzi{homMask{c}}}
  }
  
  muLoop{bulk, tern{arch_defvw>=256, 1, 2}, n, {is, M} => {
    eq:= each{OP, loadBatch{*E~~x, is, VT}}
    if (homAny{M{tree_fold{|, eq}}}) {
      findFirst{
        {i,c} => homAny{c},
        {i,c} => tup{i,c},
        end,
        is, eq
      }
    }
  }}
  n
}

fn searchOne{A, E}(x:*void, e0:A, len:u64) : u64 = {
  def e = if (A==E) e0 else cast_i{E, e0}
  search{E, x, len, {c:VT} => c == VT**e}
}

def isNegZero{x:T} = to_el{u64,x} == to_el{u64, T ** -f64~~0}
fn searchNormalizable{}(x:*f64, len:u64) : u64 = {
  search{f64, x, len, {c:VT} => isNegZero{c} | (c!=c)}
}

fn copyOrdered{}(r:*f64, x:*f64, len:u64) : u1 = {
  def E = f64
  def bulk = arch_defvw/width{E}
  def VT = [bulk]E
  maskedLoop{bulk, len, {i, M} => {
    c:= loadBatch{x, i, VT}
    if (homAny{M{c!=c}}) return{1}
    storeBatch{r, i, c + VT**0, M}
  }}
  0
}

export{'simd_search_u8',  searchOne{u64, u8}}
export{'simd_search_u16', searchOne{u64, u16}}
export{'simd_search_u32', searchOne{u64, u32}}
export{'simd_search_f64', searchOne{f64, f64}}
export{'simd_search_normalizable', searchNormalizable{}}
export{'simd_copy_ordered', copyOrdered{}}


# In-register bit table
if (hasarch{'AVX2'}) {
def TI = i8
def VI = [32]TI

def bittab_selector{loadtab} = {
  {t0, t1}:= loadtab{}
  low:= VI**7
  hi4:= VI**(-(1<<4))
  b  := VI~~make{[32]u8, 1 << (iota{32} & 7)}
  def selector{x} = {
    top := hi4 + VI~~(([8]u32~~(x&~low))>>3)
    byte:= sel{[16]i8, t0, hi4^top} | sel{[16]i8, t1, top}
    mask:= sel{[16]i8, b, x & low}
    homMask{(mask & byte) == mask}
  }
  def reload{} = { tup{t0,t1} = loadtab{} }
  tup{selector, reload}
}

def readbytes{vtab}{} = {
  def side{i} = {
    def m = @collect (vtab over _ from i to i+4) homMask{vtab}
    VI~~make{[8]u32, merge{m,m}}
  }
  each{side, 4*iota{2}}
}

# Fill table with t (0 or -1) at all bytes in x0
# Stop early if the sum u reaches 0, indicating all bytes in the table
# are equal: by the time it's checked at least one has been set to t,
# so they're all t
# If r0 is a pointer, set it to the unique mask of x0
def do_bittab{x0:*void, n:u64, tab:*void, u:u8, t, r0} = {
  btab:= *i8~~tab
  def settab_sub{x, v} = {
    u+= u8~~(t - v)  # u tracks the total of btab
    store{btab, x, t}
    v
  }
  def settab1{x} = settab_sub{x, -1 - t}       # Known new
  def settab{x} = settab_sub{x, load{btab, x}} # General case
  def settab{T, x} = T~~promote{ty_s{T}, settab{x}}

  def rbit = ~match{r0, 0}
  def storebit{i, v:T} = if (rbit) store{*T~~r0, i, v}

  # Do first few values with a scalar loop
  # Avoids the cost of ever loading the table into vectors for n<=48
  x:= *u8~~x0
  i:u64 = 32; if (n<=48) i=n
  {rw,rv} := undef{tup{u64,u32}} # Bit results, used if rbit
  if (rbit) rw = 0
  @for (x over j to i) {
    new:= settab{u64, x}
    if (rbit) rw|= new & ((u64~~1)<<j)
  }
  storebit{0, rw}
  if (not rbit and u == 0) return{u} # Won't ever trigger (m != 0)!

  def done = makelabel{}
  def {bitsel, reload_tab} = bittab_selector{readbytes{*VI~~tab}}
  xv:= *VI~~x0
  while (i < n) {
    i0:= i; iw:= i/32
    v:= load{xv, iw}
    m:= bitsel{v} # Mask of possibly-new values
    if (not match{t,0}) m^= u32~~promote{i32, t}
    i+= 32
    if (i > n) m&= (~u32~~0)>>((-n)%32)
    # Any new values?
    if (m == 0) {
      storebit{iw, m}
    } else {
      # Add values to the table and filter m
      if (rbit) rv = m
      xi:= load{x, i0 + ctzi{m}}
      settab1{xi}
      if ((m&(m-1)) != 0) { # More bits than one
        # Filter out values equal to the previous, or first new
        def pind = (iota{32}&15) - 1
        prev:= make{VI, each{bind{max,0}, pind}}
        e:= ~homMask{v == VI**TI~~xi}
        e&= base{2,pind<0} | ~homMask{v == sel{[16]i8, v, prev}}
        if (rbit) rv&= e | -m # Don't remove first bit
        m&= e
        while (m != 0) {
          new:= settab{u32, load{x, i0 + ctzi{m}}}
          m1:= m-1;  m&= m1         # Clear low bit
          if (rbit) rv&= m1 | new   # Clear if not new
        }
      }
      storebit{iw, rv}
      if (u == 0) { # All bytes seen
        if (rbit) @for (r in *u32~~r0 over _ from iw+1 to cdiv{n,32}) r = 0
        goto{done}
      }
      reload_tab{}
    }
  }
  setlabel{done}
  u
}

fn avx2_mark_firsts_u8(x0:*void, n:u64, r0:*void, tab:*void) : void = {
  init:= VI**(-1)
  @unroll (t in *VI~~tab over 8) t = init
  u:u8 = 0
  do_bittab{x0, n, tab, u, 0, r0}
}

fn fill_bittab(x0:*void, n:u64, tab:*void, u:u8, t:i8) : u8 = {
  do_bittab{x0, n, tab, u, t, 0}
}

fn avx2_member_u8(w0:*void, nw:u64, x0:*void, nx:u64, r0:*void, tab:*void) : void = {
  assert{nw > 0}
  vtab:= *VI~~tab

  # Initialize
  rev:u1 = nx < nw/4  # Reverse lookup
  z:= VI**(-promote{i8,rev})
  @unroll (vtab over 8) vtab = z
  u:u8 = 0  # Sum of table, either 0 or 256
  if (rev) u = fill_bittab(x0, nx, tab, u, 0)

  # Fill table
  u = fill_bittab(w0, nw, tab, u, -1)
  if (u == 0) { # All found!
    @for (r in *u64~~r0 over cdiv{nx,64}) r = maxvalue{u64}
    return{}
  }

  # Read result
  def {bitsel, _} = bittab_selector{readbytes{vtab}}
  @for (x in *VI~~x0, r in *u32~~r0 over cdiv{nx,32}) r = bitsel{x}
}

export{'avx2_mark_firsts_u8', avx2_mark_firsts_u8}
export{'avx2_member_u8', avx2_member_u8}
} # hasarch{'AVX2'}
