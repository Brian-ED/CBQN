include './base'
include './cbqnDefs'
local include 'skin/cext'

# Size-specific functions defined in C
def hash_val{v:T} = emit{T, merge{'hash',fmtnat{width{T}}}, v}
def memset{p:pT, v, l} = {
  emit{void, merge{'memset',fmtnat{elwidth{pT}}}, p, v, l}
}

def names = tup{'memberOf', 'count', 'indexOf'}
def prims = tup{'∊',        '⊒',     '⊐'      }
def map{f,t,v} = if (v==tupsel{0,f}) tupsel{0,t} else map{slice{f,1}, slice{t,1}, v}
def to_prim = map{names, prims, .}

# Resizing hash table, with fallback
def rty{name} = if (to_prim{name}=='∊') i8 else i32
fn selfhashtab{T, name}(rp:*rty{name}, xp:*T, n:usz) = {
  def wt = width{T}
  def prim = to_prim{name}
  def has_radix = if (prim=='⊐') 0 else wt==32
  def {res0,stop} = if (prim=='∊') tup{1,n>>has_radix} else tup{0,2*n}

  log := clzc{n}
  msl := clzc{n+n/2} + 1; if (has_radix and msl>20) msl=20
  sh  := wt - tern{msl<14, msl, 12+(msl&1)}  # Shift to fit to table
  sz  := usz~~1 << (wt - sh)  # Initial size
  msz := usz~~1 << msl        # Max sz
  b:usz = 64  # Block size

  # Resize or abort if more than 1/2^thresh collisions/element
  def {set_thresh, div_thresh} = {
    t:usz = 0          # Shift amount
    def o = prim=='⊐'  # Offset to allow effective t<0
    def div_thresh{i} = ((1<<o)*i)>>t
    def t0= has_radix*(prim=='∊')
    def w = if (prim=='⊒') 1<<6 else wt<<o
    # Threshold setter, re-applied on resize
    def set_thresh{} = {
      if      (sz==msz)                           t = t0
      else if ((not has_radix) and sz>=(1<<24)/w) t = 0+o
      else if (                    sz>=(1<<20)/w) t = 3+o
      else                                        t = 5+o
    }
    tup{set_thresh, div_thresh}
  }
  set_thresh{}

  # Filling e slots past the end requires e*(e+1)/2 collisions, so
  # n entries with <2 each can fill <sqrt(4*n)
  ext := tern{n<=b, n, b + (usz~~1 << (log/2 + 1))}
  x0 := hash_val{xp->0}; rp <-{0} res0
  def aux = prim!='∊'
  halloc := talloc{u8, (msz+ext)*((wt + aux*width{u32})/8)}
  szo := msz-sz  # Beginning of allocation to initial table
  sze := sz+ext  # Initial table to end of allocation
  hash := *T~~halloc + szo
  memset{hash, x0, sze}
  val := *u32~~(hash+sze) + szo
  if (aux) { memset{val, 0, sze} }

  def {output, write_res} = match (prim) {
    {('∊')} => tup{{b}=>b, {j,h,k,x0} => { hash<-{j}h; k!=h }}
    {('⊒')} => {
      ctr0:u32 = 1
      tup{
        {b}=>b,
        {j,h,k,x0} => {
          e0:=promote{u32,h==x0}; vj:=val->j; c0:=ctr0
          hash<-{j}h; val<-{j}vj+(e0^1); ctr0+=e0
          vj + (c0 & -e0)
        }
      }
    }
    {('⊐')} => {
      ctr:u32 = 1
      tup{
        {b}=>promote{u32,b}*ctr,
        {j,h,k,x0} => {
          if (k!=h) { val<-{j}ctr; ++ctr; hash<-{j}h }
          val->j
        }
      }
    }
  }

  def break=makelabel{}
  cc:usz = 0 # Collision counter
  i:usz=1; while (1) {
    e := tern{n-i>b, i+b, n}
    while (i < e) {
      h := hash_val{xp->i}; j0 := h>>sh; j := j0
      k:=undefined{T}; while (((k=hash->j)!=h) & (k!=x0)) ++j
      cc += cast_i{usz, j-j0}
      rp <-{i} write_res{j,h,k,x0}
      ++i
    }
    if (i == n) goto{break}
    def p64{a} = i64~~promote{u64,a}
    dc := p64{cc} - p64{div_thresh{i}}
    if (dc >= 0) {
      if (sz == msz) goto{break} # Abort
      if (has_radix and i < n/2 and sz >= 1<<18) goto{break}
      # Avoid resizing if close to the end
      if (not (cc<stop and p64{n-i}*dc < (p64{i}*p64{n+i})>>(5+log-(wt-sh)))) {
        # Resize hash, factor of 4
        def m = 2
        dif := sz*((1<<m)-1)
        sh -= m; sz <<= m
        hash -= dif
        j:usz = 0
        cc = 0
        memset{hash, x0, dif}
        if (aux) { val -= dif; memset{val, 0, dif} }
        @for (j from dif to sz + ext) {
          h := hash->j
          if (h != x0) {
            hash <-{j} x0
            k0 := h>>sh; k := k0; while (hash->k!=x0) ++k
            cc += cast_i{usz, k-k0}
            hash <-{k} h
            if (aux) { v := val->j; val <-{j} 0; val <-{k} v }
          }
        }
        if (cc >= stop) goto{break}
        set_thresh{}
      }
    }
  }
  setlabel{break}
  tfree{halloc}
  output{i == n}  # Whether it finished
}

def exp_hash{T, name} = {
  export{merge{name,'_c1_hash',fmtnat{width{T}}}, selfhashtab{T, name}}
}
each{{n}=>each{exp_hash{.,n},tup{u32,u64}}, names}
