include './base'
include './cbqnDefs'
local include 'skin/cext'

# Defined in C
def memset{p:pT, v, l} = {
  emit{void, merge{'memset',fmtnat{elwidth{pT}}}, p, v, l}
}

# These hashes are stored in tables and must be invertible!
# Murmur3
def hash_val{x0:u32} = {
  x := x0
  x ^= x >> 16; x *= 0x85ebca6b
  x ^= x >> 13; x *= 0xc2b2ae35
  x ^= x >> 16; x
}
def hash_val{x0:u64} = {
  x := x0
  x ^= x >> 33; x *= 0xff51afd7ed558ccd
  x ^= x >> 33; x *= 0xc4ceb9fe1a85ec53
  x ^= x >> 33; x
}
# CRC32
def hash_val{x:u32 & hasarch{'SSE4.2'}} = {
  emit{u32, '_mm_crc32_u32', 0x973afb51, x}
}

def hash_resize{hash,vals, x0,sh,sz,ext,cc, m} = {
  dif := sz*((1<<m)-1)
  sh -= m; sz <<= m
  hash -= dif
  j:usz = 0
  cc = 0
  memset{hash, x0, dif}
  each{{val} => { val -= dif; memset{val, 0, dif} }, vals}
  @for (j from dif to sz + ext) {
    h := hash->j
    if (h != x0) {
      hash <-{j} x0
      k0 := h>>sh; k := k0; while (hash->k!=x0) ++k
      cc += cast_i{usz, k-k0}
      hash <-{k} h
      each{{val} => { v := val->j; val <-{j} 0; val <-{k} v }, vals}
    }
  }
}

def names = tup{'memberOf', 'count', 'indexOf'}
def prims = tup{'∊',        '⊒',     '⊐'      }
def map{{f,...fs}, {t,...ts}, v} = if (v==f) t else map{fs, ts, v}
def to_prim = map{names, prims, .}

# Resizing hash table, with fallback
def rty{name} = if (to_prim{name}=='∊') i8 else i32
fn selfhashtab{T, name}(rp:*rty{name}, xp:*T, n:usz) = {
  def wt = width{T}
  def prim = to_prim{name}
  def has_radix = if (prim=='⊐') 0 else wt==32
  def {res0,stop} = if (prim=='∊') tup{1,n>>has_radix} else tup{0,2*n}

  log := clzc{n}
  msl := clzc{n+n/2} + 1; if (has_radix and msl>20) msl=20
  sh  := wt - tern{msl<14, msl, 12+(msl&1)}  # Shift to fit to table
  sz  := usz~~1 << (wt - sh)  # Initial size
  msz := usz~~1 << msl        # Max sz
  b:usz = 64  # Block size

  # Resize or abort if more than 1/2^thresh collisions/element
  def {set_thresh, div_thresh} = {
    t:usz = 0          # Shift amount
    def o = prim=='⊐'  # Offset to allow effective t<0
    def div_thresh{i} = ((1<<o)*i)>>t
    def t0= has_radix*(prim=='∊')
    def w = if (prim=='⊒') 1<<6 else wt<<o
    # Threshold setter, re-applied on resize
    def set_thresh{} = {
      if      (sz==msz)                           t = t0
      else if ((not has_radix) and sz>=(1<<24)/w) t = 0+o
      else if (                    sz>=(1<<20)/w) t = 3+o
      else                                        t = 5+o
    }
    tup{set_thresh, div_thresh}
  }
  set_thresh{}

  # Filling e slots past the end requires e*(e+1)/2 collisions, so
  # n entries with <2 each can fill <sqrt(4*n)
  ext := tern{n<=b, n, b + (usz~~1 << (log/2 + 1))}
  x0 := hash_val{xp->0}; rp <-{0} res0
  def aux = prim!='∊'
  halloc := talloc{u8, (msz+ext)*((wt + aux*width{u32})/8)}
  szo := msz-sz  # Beginning of allocation to initial table
  sze := sz+ext  # Initial table to end of allocation
  hash := *T~~halloc + szo
  memset{hash, x0, sze}
  vals := if (aux) tup{*u32~~(hash+sze) + szo} else tup{}
  each{memset{., 0, sze}, vals}

  def {output, write_res} = match (prim) {
    {('∊')} => tup{{b}=>b, {j,h,k,x0} => { hash<-{j}h; k!=h }}
    {('⊒')} => {
      ctr0:u32 = 1; def {val} = vals
      def res{j,h,k,x0} = {
        e0:=promote{u32,h==x0}; vj:=val->j; c0:=ctr0
        hash<-{j}h; val<-{j}vj+(e0^1); ctr0+=e0
        vj + (c0 & -e0)
      }
      tup{{b}=>b, res}
    }
    {('⊐')} => {
      ctr:u32 = 1; def {val} = vals
      def res{j,h,k,x0} = {
        if (k!=h) { val<-{j}ctr; ++ctr; hash<-{j}h }
        val->j
      }
      tup{{b}=>promote{u32,b}*ctr, res}
    }
  }

  def break=makelabel{}
  cc:usz = 0 # Collision counter
  i:usz=1; while (1) {
    e := tern{n-i>b, i+b, n}
    while (i < e) {
      h := hash_val{xp->i}; j0 := h>>sh; j := j0
      k:=undefined{T}; while (((k=hash->j)!=h) & (k!=x0)) ++j
      cc += cast_i{usz, j-j0}
      rp <-{i} write_res{j,h,k,x0}
      ++i
    }
    if (i == n) goto{break}
    # Check collision counter and possibly resize
    def p64 = promote{u64,.}
    dc := p64{cc} - p64{div_thresh{i}}
    if (i64~~dc >= 0) {
      if (sz == msz) goto{break} # Abort
      if (has_radix and i < n/2 and sz >= 1<<18) goto{break}
      # Avoid resizing if close to the end
      if (cc>=stop or p64{n-i}*dc >= (p64{i}*p64{n+i})>>(5+log-(wt-sh))) {
        hash_resize{hash,vals, x0,sh,sz,ext,cc, 2} # Resize hash, factor of 4
        if (cc >= stop) goto{break}
        set_thresh{}
      }
    }
  }
  setlabel{break}
  tfree{halloc}
  output{i == n}  # Whether it finished
}

def exp_hash{T, name} = {
  export{merge{name,'_c1_hash',fmtnat{width{T}}}, selfhashtab{T, name}}
}
each{{n}=>each{exp_hash{.,n},tup{u32,u64}}, names}
