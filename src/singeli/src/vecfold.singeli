# Fold associative/commutative operation across a register
# Used by squeeze.singeli, count.singeli
# Has to be included after util/tup because of name conflict

def vfold{F, x:T} = {
  show{'WARNING: using fallback fold for ', F, T}
  def E = eltype{T}
  r:E = 0
  each{{i} => { r = F{r, extract{x, i}} }, iota{vcount{T}}}
  r
}
def vfold{F, x:T & w128{T} & hasarch{'X86_64'}} = {
  c:= x
  def EW = elwidth{T}
  if (EW<=64) c = F{c, shuf{[4]u32, c, 4b1032}}
  if (EW<=32) c = F{c, shuf{[4]u32, c, 4b2301}}
  if (EW<=16) c = F{c, shuf16Lo{c, 4b2301}}
  if (EW==8) { v:=extract{[8]i16~~c, 0}; F{cast_i{eltype{T}, v}, cast_i{eltype{T}, v>>8}} }
  else extract{c, 0}
}
def vfold{F, x:T & w256{T} & hasarch{'X86_64'}} = vfold{F, F{half{x, 0}, half{x, 1}}}
